import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.CSJbQl-u.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"document/services/ruby/rails/Rails Cache 缓存.md","filePath":"document/services/ruby/rails/Rails Cache 缓存.md"}'),p={name:"document/services/ruby/rails/Rails Cache 缓存.md"},l=n(`<h2 id="redis-cache-缓存" tabindex="-1">Redis Cache 缓存 <a class="header-anchor" href="#redis-cache-缓存" aria-label="Permalink to &quot;Redis Cache 缓存&quot;">​</a></h2><p>使用缓存提升 Rails 应用的速度，缓存是指存储请求-响应循环中生成的内容，在类似请求的响应中复用 ，通常缓存是提升应用性能最有效的方式。通过缓存，在单个服务器中使用单个数据库的网站可以承受数千个用户并发访问 。</p><p>使用内存缓存存储通常可以提供较高的缓存读写速度，适用于一些短期的缓存需求。但是需要注意的是，内存缓存存储通常只在单个服务器上有效，如果应用程序需要运行在多个服务器上，则需要使用分布式缓存存储（如 memcached 或 Redis）来实现跨服务器的缓存共享。</p><p>同时，由于缓存数据存储在内存中，如果缓存数据过多或缓存过期时间设置不当，可能会导致内存占用过高，从而影响应用程序的性能和稳定性，因此在使用内存缓存存储时，需要根据具体应用场景和需求进行合理的配置和管理。</p><h2 id="组件片段缓存" tabindex="-1">组件片段缓存 <a class="header-anchor" href="#组件片段缓存" aria-label="Permalink to &quot;组件片段缓存&quot;">​</a></h2><p>本节简介三种缓存技术：~~页面缓存（page caching）、动作缓存（action caching）~~和片段缓存（fragment caching）。Rails 默认提供了片段缓存，页面动态缓存已经被删除了。<s>如果想使用页面缓存或动作缓存，要把 actionpack-page_caching 或 actionpack-action_caching 添加到 Gemfile 中。</s></p><p>默认情况下，缓存只在生产环境启用，如果想在本地启用缓存，要在相应的 <code>config/environments/*.rb</code> 文件中把 <code>config.action_controller.perform_caching 设为 true</code>。</p><p>修改 <code>config.action_controller.perform_caching</code> 的值只对 Action Controller 组件提供的缓存有影响。例如，对低层缓存没影响 。</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config.action_controller.perform_caching </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre></div><p>片段缓存，动态 Web 应用一般使用不同的组件构建页面，不是所有组件都能使用同一种缓存机制，如果页面的不同部分需要使用不同的缓存机制，在不同的条件下失效，可以使用片段缓存 ！片段缓存把视图逻辑的一部分放在 cache 块中，下次请求使用缓存存储器中的副本返回。</p><p>例如如果想缓存页面中的各个商品，可以使用下述代码：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @products.each </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> |product| </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &lt;% cache product do %&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &lt;%=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> render product </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &lt;% end %&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span></code></pre></div><p>首次访问这个页面时，Rails 会创建一个具有唯一键的缓存条目。缓存键类似这种：<code>views/products/1-201505056193031061005000/bea67108094918eeba42cd4a6e786901</code></p><p>中间的数字是 <code>product_id</code> 加上商品记录的 <code>updated_at</code> 属性中存储的时间戳。Rails 使用时间戳确保不使用过期的数据。如果 <code>updated_at</code> 的值变了，Rails 会生成一个新键，然后在那个键上写入一个新缓存，旧键上的旧缓存不再使用，这叫基于键的失效方式。</p><p>这样在用户访问商品列表的时候，如果已经缓存过的商品片段则直接返回缓存的结果，新的商品、或修改过记录的商品则走正常渲染，重新生成缓存的 key .</p><p>视图片段有变化时（例如视图的 HTML 有变），缓存的片段也失效，缓存键末尾那个字符串是模板树摘要，是基于缓存的视图片段的内容计算的 MD5 哈希值，如果视图片段有变化，MD5 哈希值就变了，因此现有文件失效，Memcached 等缓存存储器会自动删除旧的缓存文件。</p><p>如果想在特定条件下缓存一个片段，可以使用 cache_if 或 cache_unless：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache_if admin?, product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&lt;%= render product %&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span></code></pre></div><p>集合缓存：</p><p>render 辅助方法还能缓存渲染集合的单个模板，这甚至比使用 each 的前述示例更好，因为是一次性读取所有缓存模板的，而不是一次读取一个，若想缓存集合，渲染集合时传入 <code>cached: true</code> 选项：代码中所有的缓存模板一次性获取，速度更快，此外尚未缓存的模板也会写入缓存，在下次渲染时获取 。</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> render </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partial:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;products/product&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collection:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@products</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cached:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span></code></pre></div><h2 id="解决嵌套缓存问题" tabindex="-1">解决嵌套<strong>缓存问题</strong> <a class="header-anchor" href="#解决嵌套缓存问题" aria-label="Permalink to &quot;解决嵌套**缓存问题**&quot;">​</a></h2><p>有时可能想把缓存的片段嵌套在其他缓存的片段里，这叫俄罗斯套娃缓存（Russian doll caching），俄罗斯套娃缓存的优点是，更新单个商品后，重新生成外层片段时，其他内存片段可以复用。</p><p>前一节说过，如果缓存的文件对应的记录的 updated_at 属性值变了，缓存的文件失效。但是内层嵌套的片段不失效。</p><p>对下面的视图来说：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&lt;%= render product.games %&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span></code></pre></div><p>而它渲染这个视图：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache game </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&lt;%= render game %&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> %&gt;</span></span></code></pre></div><p>如果游戏的任何一个属性变了，updated_at 的值会设为当前时间，因此缓存失效，然而商品对象的 updated_at 属性不变，因此它的缓存不失效，从而导致应用使用了过期的数据，为了解决这个问题，可以使用 touch 方法把模型绑在一起 ：</p><p>把 <code>touch</code> 设为 <code>true</code> 后，导致游戏的 <code>updated_at</code> 变化的操作，也会修改关联的商品的 <code>updated_at</code> 属性，从而让缓存失效 。</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationRecord</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	has_many </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:games</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Game</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationRecord</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	belongs_to </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">touch:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="管理依赖" tabindex="-1"><strong>管理依赖</strong> <a class="header-anchor" href="#管理依赖" aria-label="Permalink to &quot;**管理依赖**&quot;">​</a></h2><p>为了正确地让缓存失效，要正确地定义缓存依赖，Rails 足够智能，能处理常见的情况，无需自己指定，但是有时需要处理自定义的辅助方法（以此为例），因此要自行定义 .</p><h3 id="_1、隐式依赖" tabindex="-1"><strong>1、隐式依赖</strong> <a class="header-anchor" href="#_1、隐式依赖" aria-label="Permalink to &quot;**1、隐式依赖**&quot;">​</a></h3><p>多数模板依赖可以从模板中的 <code>render</code> 调用中推导出来，下面举例说明 ActionView::Digestor 知道如何解码的 <code>render</code> 调用：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partial:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;comments/comment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collection:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commentable.comments</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;comments/comments&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;comments/comments&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;comments/comments&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;header&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        =&gt; render(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;comments/header&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render(@topic)         =&gt; render(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;topics/topic&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render(topics)         =&gt; render(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;topics/topic&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render(message.topics) =&gt; render(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;topics/topic&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>而另一方面，有些调用要做修改，才能让缓存正确工作，例如如果传入自定义的集合，要把下述代码：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render @project.documents.where(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">published:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>改为：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">render </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">partial:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;documents/document&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collection:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @project.documents.where(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">published:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="_2、显式依赖" tabindex="-1">2、<strong>显式依赖</strong> <a class="header-anchor" href="#_2、显式依赖" aria-label="Permalink to &quot;2、**显式依赖**&quot;">​</a></h3><p>有时模板依赖推导不出来，在辅助方法中渲染时经常是这样，下面举个例子：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> render_sortable_todolists @project.todolists </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%&gt;</span></span></code></pre></div><hr><p>此时，要使用一种特殊的注释格式：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%# Template Dependency: todolists/todolist %&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;%= render_sortable_todolists @project.todolists %&gt;</span></span></code></pre></div><hr><p>某些情况下，例如设置单表继承，可能要显式定义一堆依赖，此时无需写出每个模板，可以使用通配符匹配一个目录中的全部模板：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%# Template Dependency: events/* %&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;%= render_categorizable_events @person.events %&gt;</span></span></code></pre></div><p>对集合缓存来说，如果局部模板不是以干净的缓存调用开头，依然可以使用集合缓存，不过要在模板中的任意位置添加一种格式特殊的注释，如下所示：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%# Template Collection: notification %&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&lt;% my_helper_that_calls_cache(some_arg, notification) do %&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&lt;%= notification.name %&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;% end %&gt;</span></span></code></pre></div><h3 id="_3、外部依赖" tabindex="-1">3、<strong>外部依赖</strong> <a class="header-anchor" href="#_3、外部依赖" aria-label="Permalink to &quot;3、**外部依赖**&quot;">​</a></h3><p>如果在缓存的块中使用辅助方法，而后更新了辅助方法，还要更新缓存，具体方法不限，只要能改变模板文件的 MD5 值就行，推荐的方法之一是添加一个注释，如下所示：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%# Helper Dependency Updated: Jul 28, 2015 at 7pm %&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;%= some_helper_method(person) %&gt;</span></span></code></pre></div><h2 id="低层缓存" tabindex="-1"><strong>低层缓存</strong> <a class="header-anchor" href="#低层缓存" aria-label="Permalink to &quot;**低层缓存**&quot;">​</a></h2><p>有时需要缓存特定的值或查询结果，而不是缓存视图片段，Rails 的缓存机制能存储任何类型的信息，实现低层缓存最有效的方式是使用 <code>Rails.cache.fetch</code> 方法。</p><ul><li>这个方法既能读取也能写入缓存，传入单个参数时，获取指定的键，返回缓存中的值。</li><li>如果传入块，块中的代码在缓存缺失时执行。块返回的值将写入缓存，存在指定键的名下，然后返回那个返回值。如果命中缓存，直接返回缓存的值，而不执行块中的代码。</li></ul><p>下面举个例子，应用中有个 Product 模型，它有个实例方法，在网站中查找商品的价格，这个方法返回的数据特别适合使用低层缓存：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationRecord</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> competing_price</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		Rails</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.fetch(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">#{cache_key}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/competing_price&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">expires_in:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hours) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">			Competitor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">API</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.find_price(id)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>注意，这个示例使用了 <code>cache_key</code> 方法，因此得到的缓存键类似这种：<code>products/233-20140225082222765838000/competing_price</code>，cache_key 方法根据模型的 <code>id</code> 和 <code>updated_at</code> 属性生成一个字符串.</p><p>这是常见的约定，好处是商品更新后缓存自动失效，一般来说，使用低层缓存，缓存实例层信息时，需要生成缓存键.</p><h2 id="sql-缓存" tabindex="-1"><strong>SQL 缓存</strong> <a class="header-anchor" href="#sql-缓存" aria-label="Permalink to &quot;**SQL 缓存**&quot;">​</a></h2><p>查询缓存是 Rails 提供的一个功能，把各个查询的结果集缓存起来，如果在同一个请求中遇到了相同的查询，Rails 会使用缓存的结果集，而不再次到数据库中运行查询。</p><p>例如：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProductsController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationController</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> index</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 运行查找查询</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		@products </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.all</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 再次运行相同的查询</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		@products </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.all</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>再次运行相同的查询时，根本不会发给数据库，首次运行查询得到的结果存储在查询缓存中（内存里），第二次查询从内存中获取 ！然而要知道，查询缓存在动作开头创建，到动作末尾销毁，只在动作的存续时间内存在，如果想持久化存储查询结果，使用低层缓存也能实现。</p><h2 id="配置缓存存储器-套件" tabindex="-1">配置<strong>缓存存储器（套件）</strong> <a class="header-anchor" href="#配置缓存存储器-套件" aria-label="Permalink to &quot;配置**缓存存储器（套件）**&quot;">​</a></h2><p>Rails 为存储缓存数据（SQL 缓存和页面缓存除外）提供了不同的存储器 。</p><h3 id="configure-配置" tabindex="-1">configure <strong>配置</strong> <a class="header-anchor" href="#configure-配置" aria-label="Permalink to &quot;configure **配置**&quot;">​</a></h3><p>config.cache_store 配置选项用于设定应用的默认缓存存储器，可以设定其他参数，传给缓存存储器的构造方法</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># config.cache_store 是一个 Rails 配置选项，用于指定应用程序中所使用的缓存存储方式</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># **:memory_store 是 Rails 内置的一种缓存存储方式，表示缓存数据存储在内存中。**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 而 { size: 64.megabytes } 则是用于设置缓存存储的大小，这里设置为 64MB</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Rails</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.application.configure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	config.cache_store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :memory_store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.megabytes }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 此外还可以在配置块外部调用 ActionController::Base.cache_store，缓存存储器通过 Rails.cache 访问</span></span></code></pre></div><h3 id="activesupport-cache-store-抽象存储器类" tabindex="-1"><strong>ActiveSupport::Cache::Store 抽象存储器类</strong> <a class="header-anchor" href="#activesupport-cache-store-抽象存储器类" aria-label="Permalink to &quot;**ActiveSupport::Cache::Store 抽象存储器类**&quot;">​</a></h3><p>这个类是在 Rails 中与缓存交互的基础，这是个抽象类，不能直接使用，你必须根据存储器引擎具体实现这个类，Rails 提供了几个实现，说明如下：</p><p>主要调用的方法有 <code>read</code>、<code>write</code>、<code>delete</code>、<code>exist?</code> 和 <code>fetch</code>，fetch 方法接受一个块，返回缓存中现有的值，或者把新值写入缓存</p><p>所有缓存实现有些共用的选项，可以传给构造方法，或者传给与缓存条目交互的各个方法。</p><ul><li><code>:namespace</code>：在缓存存储器中创建命名空间，如果与其他应用共用同一个缓存存储器，这个选项特别有用。</li><li><code>:compress</code>：是否指定压缩缓存</li><li><code>:compress_threshold</code>：与 :compress 选项搭配使用，指定一个阈值，未达到时不压缩缓存，默认为 16 千字节。</li><li><code>:expires_in</code>：为缓存条目设定失效时间（秒数），失效后自动从缓存中删除。</li><li><code>:race_condition_ttl</code>：与 :expires_in 选项搭配使用，避免多个进程同时重新生成相同的缓存条目（也叫 dog pile effect），防止让缓存条目过期时出现条件竞争，这个选项设定在重新生成新值时失效的条目还可以继续使用多久（秒数）。如果使用 :expires_in 选项， 最好也设定这个选项。</li></ul><p>缓存存储器可以自己定义，只需扩展 ActiveSupport::Cache::Store 类，实现相应的方法，这样你可以把任何缓存技术带到你的 Rails 应用中，若想使用自定义的缓存存储器，只需把 cache_store 设为自定义类的实例，甚至可以集成到 redis.</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config.cache_store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyCacheStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span></span></code></pre></div><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyCacheStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ActiveSupport::Cache::Store</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> initialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# @cache 实例变量是一个 Hash 对象，用于存储缓存数据。在每次添加或读取缓存数据时，都会先在 @cache 中查找对应的缓存条目。如果缓存条目存在且未过期，则直接返回该条目的值；</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 否则需要重新生成缓存数据，并将其存储到 @cache 中</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 需要注意的是，@cache 实例变量是一个内存缓存，它会将缓存数据存储在应用程序的内存中，因此在使用缓存时，需要根据具体情况进行权衡和优化，以避免内存占用过大、缓存数据过期</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 或失效等问题，可以使用其他缓存存储器，如 Redis、Memcached 等，来实现分布式缓存和缓存持久化等功能</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @cache </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# :namespace 是一个配置选项，用于在缓存存储器中创建命名空间，以避免缓存键名称之间的冲突，如果不同的应用程序或模块共享同一个缓存存储器，使用命名空间可以将缓存条目分组</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 到不同的命名空间中，从而使缓存条目彼此独立，不会互相干扰。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	  # 在 Rails 中，可以通过在 config/application.rb 文件中配置 config.cache_store 选项来指定缓存存储器和其选项，其中可以包含 :namespace 选项，例如：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # config.cache_store = :redis_cache_store, { url: ENV[&#39;REDIS_URL&#39;], namespace: &#39;myapp_cache&#39; }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 在上面的示例中，我们指定了使用 Redis 缓存存储器，并设置了 Redis 的连接 URL 和命名空间为 &#39;myapp_cache&#39;，这样在使用缓存时，可以将缓存键名称加上命名空间前缀，以避免</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 不同应用程序之间的缓存键名称冲突。例如：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    #</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Rails.cache.write(&#39;user:1&#39;, { name: &#39;Alice&#39; })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# Rails.cache.read(&#39;user:1&#39;) # =&gt; { name: &#39;Alice&#39; }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 我们使用了 &#39;user:1&#39; 作为缓存键名称，并将其存储到了缓存存储器中，由于我们在配置缓存存储器时设置了命名空间为 &#39;myapp_cache&#39;，因此实际存储的缓存键名称为 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # &#39;myapp_cache:user:1&#39; 这样即使其他应用程序或模块也使用了 &#39;user:1&#39; 作为缓存键名称，也不会与我们的缓存键名称发生冲突</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @namespace </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:namespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# :compress 是一个缓存选项，用于指定是否对缓存进行压缩，当缓存中存储了大量数据时，如果直接通过缓慢的网络传输这些数据，可能会导致网络传输速度慢、占用带宽等问题，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 影响系统性能，因此在这种情况下可以使用压缩缓存来减小数据传输的大小，从而提高系统性能</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @compress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:compress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 与 :compress 选项搭配使用，指定一个阈值，未达到时不压缩缓存，默认为 16 千字节</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @compress_threshold </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:compress_threshold</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 为缓存条目设定失效时间（秒数），失效后自动从缓存中删除</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @expires_in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:expires_in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # @race_condition_ttl 实例变量的值表示缓存条目的竞争条件生存时间。在多个并发请求同时访问同一个缓存条目时，可能会出现竞争条件，即多个请求同时读取缓存条目的过程中，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 缓存条目的值被删除或过期。为了避免竞争条件的发生，可以在缓存条目的过期时间之后，再设置一个竞争条件生存时间，在这段时间内，即使缓存条目过期了，也不会被删除，以便其他</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 请求可以继续使用该缓存条目，在示例中，我们设置了默认值为 nil，即不使用竞争条件生存时间，实际上这个值应该根据具体情况进行调整，需要考虑缓存的访问频率、并发访问的情况</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 等因素，以便达到最优的性能和效果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @race_condition_ttl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:race_condition_ttl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	# 读取缓存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normalize_key(key, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @cache[key]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:expires_in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:expires_in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.now</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        delete(key, options)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # 在 Ruby 中，可以使用 ActiveSupport::Gzip 模块来实现缓存压缩功能。具体的方法如下：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # require &#39;active_support/gzip&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		  # 压缩数据</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		  #	compressed_data = ActiveSupport::Gzip.compress(data)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		  #	解压数据</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		  # uncompressed_data = ActiveSupport::Gzip.decompress(compressed_data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ActiveSupport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gzip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.decompress(value) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @compress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value.bytesize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @compress_threshold</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      value</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	# 写入缓存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, value, options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normalize_key(key, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ActiveSupport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gzip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.compress(value) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @compress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value.bytesize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @compress_threshold</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entry[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entry[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:expires_in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @expires_in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @expires_in</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @cache[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	# 删除缓存</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normalize_key(key, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @cache.delete(key)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 判断是否有指定 key </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> exist?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> normalize_key(key, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    entry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @cache[key]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:expires_in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> entry[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:expires_in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.now</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        delete(key, options)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      false</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	# 写入缓存，接收一个块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">block)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exist?(key, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      read(key, options)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block.call</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      write(key, value, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      value</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	# 命名 key name</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> normalize_key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">#{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@namespace</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">#{key}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @namespace.present?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h3 id="activesupport-cache-memorystore-内存存储器" tabindex="-1"><strong>ActiveSupport::Cache::MemoryStore (内存存储器)</strong> <a class="header-anchor" href="#activesupport-cache-memorystore-内存存储器" aria-label="Permalink to &quot;**ActiveSupport::Cache::MemoryStore (内存存储器)**&quot;">​</a></h3><p>这个缓存存储器把缓存条目放在内存中，与 Ruby 进程放在一起，可以把 :size 选项传给构造方法，指定缓存的大小限制（默认为 32Mb），超过分配的大小后，会清理缓存，把最不常用的条目删除</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config.cache_store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :memory_store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.megabytes }</span></span></code></pre></div><p>如果运行多个 Ruby on Rails 服务器进程（例如使用 Phusion Passenger 或 Puma 集群模式），各个实例之间无法共享缓存数据，这个缓存存储器不适合大型应用使用，不过适合只有几个服务器进程的低流量小型应用使用，也适合在开发环境和测试环境中使用</p><h3 id="activesupport-cache-filestore-文件存储器" tabindex="-1">ActiveSupport::Cache::FileStore (文件存储器) <a class="header-anchor" href="#activesupport-cache-filestore-文件存储器" aria-label="Permalink to &quot;ActiveSupport::Cache::FileStore (文件存储器)&quot;">​</a></h3><p>这个缓存存储器使用文件系统存储缓存条目，初始化这个存储器时，必须指定存储文件的目录：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config.cache_store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :file_store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/cache/directory&quot;</span></span></code></pre></div><p>使用这个缓存存储器时，在同一台主机中运行的多个服务器进程可以共享缓存，这个缓存存储器适合一到两个主机的中低流量网站使用，运行在不同主机中的多个服务器进程若想共享缓存，可以使用共享的文件系统，但是不建议这么做 ，缓存量一直增加，直到填满磁盘，所以建议你定期清理旧缓存条目，这是默认的缓存存储器。</p><h3 id="activesupport-cache-memcachestore-memcached-共享中心化的存储器" tabindex="-1">ActiveSupport::Cache::MemCacheStore（memcached 共享中心化的存储器） <a class="header-anchor" href="#activesupport-cache-memcachestore-memcached-共享中心化的存储器" aria-label="Permalink to &quot;ActiveSupport::Cache::MemCacheStore（memcached 共享中心化的存储器）&quot;">​</a></h3><p>这个缓存存储器使用 Danga 的 memcached 服务器为应用提供中心化缓存，Rails 默认使用自带的 dalli gem，这是生产环境的网站目前最常使用的缓存存储器，通过它可以实现单个共享的缓存集群，效率很高，有较好的冗余。</p><p>初始化这个缓存存储器时，要指定集群中所有 memcached 服务器的地址，如果不指定，假定 memcached 运行在本地的默认端口上，但是对大型网站来说，这样做并不好。</p><p>这个缓存存储器的 write 和 fetch 方法接受两个额外的选项，以便利用 memcached 的独有特性，指定 :raw 时，直接把值发给服务器，不做序列化，值必须是字符串或数字。memcached 的直接操作，如 increment 和 decrement，只能用于原始值。还可以指定 :unless_exist 选项，不让 memcached 覆盖现有条目。</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 小屋里面使用了 dalli_store 存储器，而官网并没有介绍 mem_cache_store，所以我提出了为什么不使用 mem_cache_store 而是 dalli_store</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># config.cache_store = [:dalli_store, Rails.application.secrets.memcached, { compress: true }] </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 在 Rails 3 中，使用的确是 :mem_cache_store，它表示使用 Memcached 存储器作为缓存存储器</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 而在 Rails 4 中，引入了 Dalli 存储器，它是一个基于 Memcached 的 Ruby 缓存，客户端可以用于连接 Memcached 服务器，并实现缓存数据的读取、存储、删除等操作</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 因此，在 Rails 4 中，可以使用 :dalli_store 作为缓存存储器，以替代 :mem_cache_store</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 实际上 dalli_store 是基于 mem_cache_store 的一种改进，它提供了更好的性能和可靠性，同时支持更多的特性和功能，如压缩、序列化、CAS 等。因此，在使用 Rails 进行缓存时，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 建议使用 :dalli_store 作为缓存存储器，以获得更好的性能和效果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config.cache_store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :mem_cache_store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cache-1.example.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cache-2.example.com&quot;</span></span></code></pre></div><h3 id="activesupport-cache-nullstore-无结果存储器" tabindex="-1">ActiveSupport::Cache::NullStore (无结果存储器) <a class="header-anchor" href="#activesupport-cache-nullstore-无结果存储器" aria-label="Permalink to &quot;ActiveSupport::Cache::NullStore (无结果存储器)&quot;">​</a></h3><p>这个缓存存储器只应该在开发或测试环境中使用，它并不存储任何信息，在开发环境中，如果代码直接与 Rails.cache 交互，但是缓存可能对代码的结果有影响，可以使用这个缓存存储器，在这个缓存存储器上调用 fetch 和 read 方法不返回任何值 。</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">config.cache_store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :null_store</span></span></code></pre></div><h2 id="缓存键规则" tabindex="-1"><strong>缓存键规则</strong> <a class="header-anchor" href="#缓存键规则" aria-label="Permalink to &quot;**缓存键规则**&quot;">​</a></h2><p>缓存中使用的键可以是能响应 cache_key 或 to_param 方法的任何对象，如果想定制生成键的方式，可以覆盖 cache_key 方法，Active Record 根据类名和记录 ID 生成缓存键，</p><p>缓存键的值可以是散列或数组，这是一个有效的缓存键，比如是一个散列也可以是一个 key { site: <em>&quot;<em>mysite</em>&quot;</em>, owners: [owner_1, owner_2] }</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Rails</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.cache.read(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">site:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*mysite*&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">owners:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [owner_1, owner_2])</span></span></code></pre></div><p>Rails.cache 使用的键与存储引擎使用的并不相同，存储引擎使用的键可能含有命名空间，或者根据后端的限制做调整，这意味着使用 Rails.cache 存储值时使用的键可能无法用于供 dalli gem 获取缓存条目，然而你也无需担心会超出 memcached 的大小限制，或者违背句法规则，Rails cache 做了处理。</p><h2 id="get-请求的条件支持" tabindex="-1"><strong>GET 请求的条件支持</strong> <a class="header-anchor" href="#get-请求的条件支持" aria-label="Permalink to &quot;**GET 请求的条件支持**&quot;">​</a></h2><p>条件 GET 请求是 HTTP 规范的一个特性，以此告诉 Web 浏览器，GET 请求的响应自上次请求之后没有变化，可以放心从浏览器的缓存中读取。</p><p>为此，要传递 HTTP_IF_NONE_MATCH 和 HTTP_IF_MODIFIED_SINCE 首部，其值分别为唯一的内容标识符和上一次改动时的时间戳，浏览器发送的请求，如果内容标识符（etag）或上一次修改的时间戳与服务器中的版本匹配，那么服务器只需返回一个空响应，把状态设为未修改。</p><p>服务器（也就是我们自己）要负责查看最后修改时间戳和 HTTP_IF_NONE_MATCH 首部，判断要不要返回完整的响应。既然 Rails 支持条件 GET 请求，那么这个任务就非常简单：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProductsController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationController</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> show</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		@product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.find(params[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 如果根据指定的时间戳和 etag 值判断请求的内容过期了</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# （即需要重新处理）执行这个块</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# stale? 方法的作用是判断客户端的缓存是否仍然有效</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stale?(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">last_modified:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @product.updated_at.utc, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">etag:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @product.cache_key)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			respond_to </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> |wants|</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			# ... 正常处理响应</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 如果请求的内容还新鲜（即未修改），无需做任何事</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# render 默认使用前面 stale? 中的参数做检查，会自动发送 :not_modified 响应</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		# 就这样，工作结束</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>除了散列，还可以传入模型，Rails 会使用 updated_at 和 cache_key 方法设定 last_modified 和 etag：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProductsController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationController</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> show</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		@product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.find(params[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stale?(@product)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			respond_to </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> |wants|</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				# ... 正常处理响应</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>如果无需特殊处理响应，而且使用默认的渲染机制（即不使用 respond_to，或者不自己调用 render），可以使用 fresh_when 简化这个过程：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProductsController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationController</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	# 如果请求的内容是新鲜的，自动返回 :not_modified</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	# 否则渲染默认的模板（product.*）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> show</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		@product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.find(params[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		fresh_when </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">last_modified:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @product.published_at.utc, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">etag:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @product</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>有时，我们需要缓存响应，例如永不过期的静态页面。为此可以使用 http_cache_forever 辅助方法，让浏览器和代理无限期缓存。默认情况下，缓存的响应是私有的，只在用户的 Web 浏览器中缓存，如果想让代理缓存响应，设定 public: true，让代理把缓存的响应提供给所有用户。</p><p>使用这个辅助方法时，last_modified 首部的值被设为 Time.new(2011, 1, 1).utc，expires 首部的值被设为 100 年。使用这个方法时要小心，因为浏览器和代理不会作废缓存的响应，除非强制清除浏览器缓存。</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HomeController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationController</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> index</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		http_cache_forever(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">public:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			render</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="强-etag-与弱-etag" tabindex="-1"><strong>强 Etag 与弱 Etag</strong> <a class="header-anchor" href="#强-etag-与弱-etag" aria-label="Permalink to &quot;**强 Etag 与弱 Etag**&quot;">​</a></h2><p>在 HTTP 协议中，ETag 是实体标签（Entity Tag）的缩写，用于标识 HTTP 实体的版本号，它是由服务器生成的一个字符串，用于表示一个特定资源的版本，当服务器上的资源发生变化时，ETag 的值也会发生变化，客户端可以通过比较 ETag 的值来判断资源是否已经发生变化，从而避免重复传输已经存在的资源。</p><p>在 Rails 中，ETag 主要用于控制缓存和优化网络传输，当客户端请求一个资源时，服务器可以根据该资源的 ETag 值来判断客户端的缓存是否仍然有效，如果有效则可以直接返回 304 Not Modified 状态码，告诉客户端可以使用缓存数据。否则服务器会返回新的资源数据，并更新客户端的缓存。</p><p>在使用 Rails 的 stale? 方法时，可以使用 etag 参数来指定资源的 ETag 值，比较客户端缓存和服务器缓存是否一致，如果一致，则可以使用缓存数据，否则需要重新生成数据并更新缓存，通常情况下 ETag 的值可以使用对象的 cache_key 方法来生成，以确保唯一性和正确性。</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">W</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;618bbc92e2d35ea1945008b42799b0e7&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> =&gt; 弱 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ETag</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;618bbc92e2d35ea1945008b42799b0e7&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   =&gt; 强 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ETag</span></span></code></pre></div><p>Rails 默认生成弱 ETag，这种 Etag 允许语义等效但主体不完全匹配的响应具有相同的 Etag，如果响应主体有微小改动，而不想重新渲染页面，可以使用这种 Etag，为了与强 Etag 区别，弱 Etag 前面有 W/</p><p>与弱 Etag 不同，强 Etag 要求响应完全一样，不能有一个字节的差异，在大型视频或 PDF 文件内部做 Range 查询时用得到，有些 CDN，如 Akamai，只支持强 Etag，如果确实想生成强 Etag，可以这么做 ：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProductsController</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ApplicationController</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> show</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		@product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.find(params[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		fresh_when </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">last_modified:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @product.published_at.utc, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">strong_etag:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @product</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>也可以直接在响应上设定强 Etag：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">response.strong_etag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.body</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># =&gt; &quot;618bbc92e2d35ea1945008b42799b0e7&quot;</span></span></code></pre></div><h2 id="开发环境中测试缓存" tabindex="-1"><strong>开发环境中测试缓存</strong> <a class="header-anchor" href="#开发环境中测试缓存" aria-label="Permalink to &quot;**开发环境中测试缓存**&quot;">​</a></h2><p>我们经常需要在开发模式中测试应用采用的缓存策略。Rails 提供的 Rake 任务 dev:cache 能轻易启停缓存。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bin/rails dev:cache        现在正在缓存开发模式</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bin/rails dev:cache        不再缓存开发模式</span></span></code></pre></div>`,125),t=[l];function e(h,k,r,d,c,g){return a(),i("div",null,t)}const y=s(p,[["render",e]]);export{E as __pageData,y as default};
