<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | VitePress</title>
    <meta name="description" content="bolg ...">
    <meta name="generator" content="VitePress v1.0.0-rc.44">
    <link rel="preload stylesheet" href="/assets/style.COYS9-AQ.css" as="style">
    
    <script type="module" src="/assets/app.BahLFTMz.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Bu8hRsVA.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.Dc3ngIYm.js">
    <link rel="modulepreload" href="/assets/chunks/theme.DPLJ0_Tk.js">
    <link rel="modulepreload" href="/assets/document_services_redis.md.C_q9rnPa.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-3efcd581><div class="wrapper" data-v-3efcd581><div class="container" data-v-3efcd581><div class="title" data-v-3efcd581><div class="VPNavBarTitle" data-v-3efcd581 data-v-0ad69264><a class="title" href="/" data-v-0ad69264><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.png" alt data-v-ab19afbb><!--]--><!----><!--[--><!--]--></a></div></div><div class="content" data-v-3efcd581><div class="content-body" data-v-3efcd581><!--[--><!--]--><div class="VPNavBarSearch search" data-v-3efcd581><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-3efcd581 data-v-f732b5d0><span id="main-nav-aria-label" class="visually-hidden" data-v-f732b5d0>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-f732b5d0 data-v-cb318fec><!--[--><span data-v-cb318fec>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-f732b5d0 data-v-cb318fec><!--[--><span data-v-cb318fec>联系我</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-3efcd581 data-v-283b26e9><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-283b26e9 data-v-7df97737 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-7df97737></span><span class="vpi-moon moon" data-v-7df97737></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-3efcd581 data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zouzhu-code-89" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-github" /></a><a class="VPSocialLink no-icon" href="..." aria-label="twitter" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-twitter" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-3efcd581 data-v-8e87c032 data-v-af5898d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-af5898d3><span class="vpi-more-horizontal icon" data-v-af5898d3></span></button><div class="menu" data-v-af5898d3><div class="VPMenu" data-v-af5898d3 data-v-e42ed9b3><!----><!--[--><!--[--><!----><div class="group" data-v-8e87c032><div class="item appearance" data-v-8e87c032><p class="label" data-v-8e87c032>Appearance</p><div class="appearance-action" data-v-8e87c032><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-8e87c032 data-v-7df97737 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-7df97737></span><span class="vpi-moon moon" data-v-7df97737></span><!--]--></span></span></button></div></div></div><div class="group" data-v-8e87c032><div class="item social-links" data-v-8e87c032><div class="VPSocialLinks social-links-list" data-v-8e87c032 data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/zouzhu-code-89" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-github" /></a><a class="VPSocialLink no-icon" href="..." aria-label="twitter" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-twitter" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-3efcd581 data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-3efcd581><div class="divider-line" data-v-3efcd581></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-0b5c97a1><button data-v-0b5c97a1>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-cb998dce data-v-6b52fe58><div class="content" data-v-6b52fe58><div class="outline-marker" data-v-6b52fe58></div><div class="outline-title" role="heading" aria-level="2" data-v-6b52fe58>目录大纲</div><nav aria-labelledby="doc-outline-aria-label" data-v-6b52fe58><span class="visually-hidden" id="doc-outline-aria-label" data-v-6b52fe58> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-6b52fe58 data-v-53c99d69><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _document_services_redis" data-v-e6f2a212><div><h1 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to &quot;Redis&quot;">​</a></h1><p>Redis ：Remote Dictionary Server(远程字典服务器)，是完全开源免费的，用 C 语言编写的遵守 BSD 协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的 NoSQL 数据库，是当前最热门的 NoSQL 数据库之一，也被人们称为数据结构服务器，Redis 与其他 key - value 缓存产品有以下三个特点 ：</p><p>1、Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>2、Redis 不仅仅支持简单的 key - value 类型的数据，同时还提供 list、set、zset、hash 等数据结构的存储。</p><p>3、Redis 支持数据的备份，即 master - slave 模式的数据备份。</p><h2 id="redis-基本介绍" tabindex="-1">Redis 基本介绍 <a class="header-anchor" href="#redis-基本介绍" aria-label="Permalink to &quot;Redis 基本介绍&quot;">​</a></h2><ul><li>单进程：单进程模型来处理客户端的请求。对读写等事件的相应。是通过 epoll 函数的包装来做到的。Redis 的实际处理速度完全依靠主进程的执行效率。Epoll 是 linux 内核为处理大批量文件描述符而作了改进的 epoll，是 linux下多路复用 IO 接口 select/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的下同 CPU 利用率。</li><li>默认 16 个库，类似数组下标从零开始，初始默认使用零号库。</li><li>select 命令切换数据库。</li><li>Dbsize 查看当前数据库的 key 的数量。</li><li>Flushdb：清空当前库。</li><li>Flushall：通杀全部库。</li><li>统一密码管理，16个库都是同样密码，要么都ok要么一个也连接不上。</li><li>Redis索引都是从零开始。</li><li>为什么默认端口是6379。</li></ul><p>redis 的配置文件 redis-services-config.conf 中有这一行配置，说明 redis 是有 16 个仓库</p><p><code># Set the number of databases. The default database is DB 0, you can select</code></p><p><code># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</code></p><p><code># dbid is a number between 0 and &#39;databases&#39;-1</code></p><p><code>databases 16</code></p><h2 id="redis-shell-操作" tabindex="-1">Redis Shell 操作 <a class="header-anchor" href="#redis-shell-操作" aria-label="Permalink to &quot;Redis Shell 操作&quot;">​</a></h2><h3 id="key-键操作" tabindex="-1">Key 键操作 <a class="header-anchor" href="#key-键操作" aria-label="Permalink to &quot;Key 键操作&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>del key                                    # 该命令用于在 key 存在时删除 key</span></span>
<span class="line"><span>exists key                                 # 检查给定 key 是否存在</span></span>
<span class="line"><span>expire key seconds                         # 为给定 key 设置过期时间，以秒计</span></span>
<span class="line"><span>expireat key timestamp                     # expireat 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳</span></span>
<span class="line"><span>pexpire key milliseconds                   # 设置 key 的过期时间以毫秒计</span></span>
<span class="line"><span>pexpireat key milliseconds-timestamp       # 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</span></span>
<span class="line"><span>keys pattern                               # 查找所有符合给定模式( pattern)的 key</span></span>
<span class="line"><span>move key db                                # 将当前数据库的 key 移动到给定的数据库 db 当中</span></span>
<span class="line"><span>persist key                                # 移除 key 的过期时间，key 将持久保持。</span></span>
<span class="line"><span>pllt key                                   # 以毫秒为单位返回 key 的剩余的过期时间</span></span>
<span class="line"><span>ttl key                                    # 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)</span></span>
<span class="line"><span>randomkey                                  # 从当前数据库中随机返回一个 key</span></span>
<span class="line"><span>rename key newkey                          # 修改 key 的名称</span></span>
<span class="line"><span>renamenx key newkey                        # 仅当 newkey 不存在时，将 key 改名为 newkey</span></span>
<span class="line"><span>type key                                   # 返回 key 所储存的值的类型</span></span></code></pre></div><h3 id="string-字符串类型" tabindex="-1">String 字符串类型 <a class="header-anchor" href="#string-字符串类型" aria-label="Permalink to &quot;String 字符串类型&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>set key value                      # 保存到库中</span></span>
<span class="line"><span>get key                            # 获取库中值</span></span>
<span class="line"><span>getset key value                   # 设置 key 的值为 value，并返回旧值，更新值</span></span>
<span class="line"><span>incr key                           # 将 key 的值加1，如果 key 不存在，则先初始化 0，在加 1</span></span>
<span class="line"><span>decr key                           # 将 key 的值减一，如果 key 不存在，则先初始化 0，在减 1</span></span>
<span class="line"><span>setex key time value               # 设置 key 的值，并将 key 的生存时间设为 seconds 多少秒 (以秒为单位)  set  key  time  value</span></span>
<span class="line"><span>setnx key value                    # 如果 key 不存在，则 set 值，存在则不设置值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>strlen key                         # 命令用于获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误</span></span>
<span class="line"><span>append key value                   # 如果 key 存在且是字符串，则将值追加到 key 追加到原来旧值的末尾</span></span>
<span class="line"><span>incrby key value                   # 将 key 所储存的值加上增量值，如果 key 不存在，则先初始化，在执行增加量</span></span>
<span class="line"><span>decrby key value                   # 将 key 所储存的值减去减量值，如果 key 不存在，则先初始化，在执行减量值</span></span>
<span class="line"><span>getrange key start end             # 获取 key 中字符值，并从 start 开始到 end 结束的子字符串</span></span>
<span class="line"><span>setrange key offset value          # 命令用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始</span></span>
<span class="line"><span>mset key1 value1 key2 value2       # 同时设置一个或者多个 key-value</span></span>
<span class="line"><span>mget key1 key2 key3                # 获取所有(一个或多个)给定 key 的值</span></span>
<span class="line"><span>msetnx key1 value1 key2 value2     # 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在时才能设置成功，否则只要有一个 key 存在都会失败</span></span></code></pre></div><h3 id="list-列表类型" tabindex="-1">List 列表类型 <a class="header-anchor" href="#list-列表类型" aria-label="Permalink to &quot;List 列表类型&quot;">​</a></h3><p>Redis List 类型类似 Java 的 LinkedList，通过链表来完成，向其添加元素速度非常快，但按照索引方式获取元素比较慢。因此 List 结构适合那种大数据量， 要求插入速度极快的场景 。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ lpush key_name [value1] [value2] ...  # 新建列表并插入数据，lpush 是从左边插入，rpush是从右边插入</span></span>
<span class="line"><span>$ lrange key_name [index0] [index1]     # 查看列表的数据，索引是从末尾开始</span></span>
<span class="line"><span>$ lpop key_name                         # 取出列表里面的数据 ，lpop是取出头部第一个元素，rpop是取出尾部第一个元素，如果列表为空，会返回一个 nil</span></span>
<span class="line"><span>$ blpop key_name                        # 取出列表里面的数据，blpop 和 brpop 与上面不同的是，当列表为空时，将处于等待状态或者阻塞状态</span></span>
<span class="line"><span>$ llen key_name                         # 显示列表长度</span></span></code></pre></div><p>列表类型的应用场景 ：</p><p>List 结构可以用在多个场合， 比如消息服务，通过 rpush 追加消息，其他客户端可以通过 lpop 或者 rpop 读取 List 的消息。 再比如网站的新闻列表，记录可以通过 lpush 放到新闻列表中，然后访问用户可以通过 lrange 0 9 来读取最新的 10 条记录 。</p><h3 id="hash-哈希类型" tabindex="-1">Hash 哈希类型 <a class="header-anchor" href="#hash-哈希类型" aria-label="Permalink to &quot;Hash 哈希类型&quot;">​</a></h3><p>Reids Hash 类似 Java 的 HashMap，允许存放多个 Key-Value 。Spring Boot 在 Spring Session 中即采用了 Hash 结构来存放用户的 Session 数据，以实现 Web 系统的水平扩展 。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ hset key field value                # 给指定的 Key 设置一个字段值，如果值已经存在，则覆盖 。返回 0 表示失败；返回 1 表示成功</span></span>
<span class="line"><span>$ hget key filed                      # 获取指定 key 的 filed 字段的值，如果不存在，返回 nil</span></span>
<span class="line"><span>$ hexists key filed                   # 判断指定的 key 的自 field 字段是否存在，返回 1 表示存在， 0 表示不存在</span></span>
<span class="line"><span>$ hkeys key                           # 返回 Key 所指定的 hash 所有的字段名</span></span>
<span class="line"><span>$ hgetall key                         # 返回所有的字段名和字段值</span></span>
<span class="line"><span>$ hdel key field [field]              # 删除多个字段</span></span>
<span class="line"><span></span></span>
<span class="line"><span>应用场景：假设系统的用户 session 会话保存到 Redis 中，Key 值的格式是 session:{sessionld｝，以下的 sessionld 假设为“lxac”；</span></span>
<span class="line"><span>Hash 的字段支持递增计算，这跟原始类型操作一样，是原子操作：</span></span>
<span class="line"><span>hincby key field value                # 对 Key 指定的 Hash 数据中的 field 的值进行计算，增加整型 value</span></span>
<span class="line"><span>hincbyfloat key field value           # 对 Key 指定的 Hash 数据中的 field 的值进行计算，增加浮点数 value</span></span></code></pre></div><h3 id="set-无序集合类型" tabindex="-1">Set 无序集合类型 <a class="header-anchor" href="#set-无序集合类型" aria-label="Permalink to &quot;Set  无序集合类型&quot;">​</a></h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1) 。集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员) 。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis 127.0.0.1:6379&gt; SADD runoobkey redis</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SADD runoobkey mongodb</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; SMEMBERS runoobkey</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;mysql&quot;</span></span>
<span class="line"><span>2) &quot;mongodb&quot;</span></span>
<span class="line"><span>3) &quot;redis&quot;</span></span>
<span class="line"><span>在以上实例中我们通过 SADD 命令向名为 runoobkey 的集合插入的三个元素</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>SADD key member1 [member2]                         # 向集合添加一个或多个成员</span></span>
<span class="line"><span>SCARD key                                          # 获取集合的成员数</span></span>
<span class="line"><span>SDIFF key1 [key2]                                  # 返回给定所有集合的差集</span></span>
<span class="line"><span>SDIFFSTORE destination key1 [key2]                 # 返回给定所有集合的差集并存储在 destination 中</span></span>
<span class="line"><span>SINTER key1 [key2]                                 # 返回给定所有集合的交集</span></span>
<span class="line"><span>SINTERSTORE destination key1 [key2]                # 返回给定所有集合的交集并存储在 destination 中</span></span>
<span class="line"><span>SISMEMBER key member                               # 判断 member 元素是否是集合 key 的成员</span></span>
<span class="line"><span>SMEMBERS key                                       # 返回集合中的所有成员</span></span>
<span class="line"><span>SMOVE source destination member                    # 将 member 元素从 source 集合移动到 destination 集合</span></span>
<span class="line"><span>SPOP key                                           # 移除并返回集合中的一个随机元素</span></span>
<span class="line"><span>SRANDMEMBER key [count]                            # 返回集合中一个或多个随机数</span></span>
<span class="line"><span>SREM key member1 [member2]                         # 移除集合中一个或多个成员</span></span>
<span class="line"><span>SUNION key1 [key2]                                 # 返回所有给定集合的并集</span></span>
<span class="line"><span>SUNIONSTORE destination key1 [key2]                # 所有给定集合的并集存储在 destination 集合中</span></span>
<span class="line"><span>SSCAN key cursor [MATCH pattern] [COUNT count]     # 迭代集合中的元素</span></span></code></pre></div><h3 id="sorted-set-有序集合" tabindex="-1">Sorted Set 有序集合 <a class="header-anchor" href="#sorted-set-有序集合" aria-label="Permalink to &quot;Sorted Set 有序集合&quot;">​</a></h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span></span>
<span class="line"><span>(integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql</span></span>
<span class="line"><span>(integer) 0</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;redis&quot;</span></span>
<span class="line"><span>2) &quot;1&quot;</span></span>
<span class="line"><span>3) &quot;mongodb&quot;</span></span>
<span class="line"><span>4) &quot;2&quot;</span></span>
<span class="line"><span>5) &quot;mysql&quot;</span></span>
<span class="line"><span>6) &quot;4&quot;</span></span>
<span class="line"><span>在以上实例中我们通过命令 ZADD 向 redis 的有序集合中添加了三个值并关联上分数。</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ZADD key score1 member1 [score2 member2]         # 向有序集合添加一个或多个成员，或者更新已存在成员的分数</span></span>
<span class="line"><span>ZCARD key                                        # 获取有序集合的成员数</span></span>
<span class="line"><span>ZCOUNT key min max                               # 计算在有序集合中指定区间分数的成员数</span></span>
<span class="line"><span>ZINCRBY key increment member                     # 有序集合中对指定成员的分数加上增量 increment</span></span>
<span class="line"><span>ZINTERSTORE destination numkeys key [key ...]    # 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</span></span>
<span class="line"><span>ZLEXCOUNT key min max                            # 在有序集合中计算指定字典区间内成员数量         </span></span>
<span class="line"><span>ZRANGE key start stop [WITHSCORES]               # 通过索引区间返回有序集合成指定区间内的成员</span></span>
<span class="line"><span>ZRANGEBYLEX key min max [LIMIT offset count]     # 通过字典区间返回有序集合的成员</span></span>
<span class="line"><span>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]   # 通过分数返回有序集合指定区间内的成员</span></span>
<span class="line"><span>ZRANK key member                                 # 返回有序集合中指定成员的索引</span></span>
<span class="line"><span>ZREM key member [member ...]                     # 移除有序集合中的一个或多个成员</span></span>
<span class="line"><span>ZREMRANGEBYLEX key min max                       # 移除有序集合中给定的字典区间的所有成员</span></span>
<span class="line"><span>ZREMRANGEBYRANK key start stop                   # 移除有序集合中给定的排名区间的所有成员</span></span>
<span class="line"><span>ZREMRANGEBYSCORE key min max                     # 移除有序集合中给定的分数区间的所有成员</span></span>
<span class="line"><span>ZREVRANGE key start stop [WITHSCORES]            # 返回有序集中指定区间内的成员，通过索引，分数从高到底</span></span>
<span class="line"><span>ZREVRANGEBYSCORE key max min [WITHSCORES]        # 返回有序集中指定分数区间内的成员，分数从高到低排序</span></span>
<span class="line"><span>ZREVRANK key member                              # 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</span></span>
<span class="line"><span>ZSCORE key member                                # 返回有序集中，成员的分数值</span></span>
<span class="line"><span>ZUNIONSTORE destination numkeys key [key ...]    # 计算给定的一个或多个有序集的并集，并存储在新的 key 中</span></span>
<span class="line"><span>ZSCAN key cursor [MATCH pattern] [COUNT count]   # 迭代有序集合中的元素（包括元素成员和元素分值）</span></span></code></pre></div><h3 id="hyperloglog" tabindex="-1">HyperLogLog <a class="header-anchor" href="#hyperloglog" aria-label="Permalink to &quot;HyperLogLog&quot;">​</a></h3><p>HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的，在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素 。 什么是基数? 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数，以下实例演示了 HyperLogLog 的工作过程：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;redis&quot;</span></span>
<span class="line"><span>1) (integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mongodb&quot;</span></span>
<span class="line"><span>1) (integer) 1</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; PFADD runoobkey &quot;mysql&quot;</span></span>
<span class="line"><span>1) (integer) 1 redis</span></span>
<span class="line"><span>127.0.0.1:6379&gt; PFCOUNT runoobkey</span></span>
<span class="line"><span>(integer) 3</span></span>
<span class="line"><span>下表列出了 redis HyperLogLog  的基本命令：序号命令及描述</span></span>
<span class="line"><span>添加指定元素到 HyperLogLog 中</span></span>
<span class="line"><span>pfadd key element [element ...]</span></span>
<span class="line"><span>返回给定 HyperLogLog 的基数估算值</span></span>
<span class="line"><span>pfcount key [key ...]</span></span>
<span class="line"><span>将多个 HyperLogLog 合并为一个 HyperLogLog</span></span>
<span class="line"><span>pfmerge destkey sourcekey [sourcekey ...]</span></span></code></pre></div><h2 id="redis-事务" tabindex="-1">Redis 事务 <a class="header-anchor" href="#redis-事务" aria-label="Permalink to &quot;Redis 事务&quot;">​</a></h2><h3 id="multi-开启事务" tabindex="-1">multi 开启事务 <a class="header-anchor" href="#multi-开启事务" aria-label="Permalink to &quot;multi 开启事务&quot;">​</a></h3><p>redis 中开启事务是 multi 命令，而执行事务是 exec 命令，multi 到 exec 命令之间的 redis 命令将采取进行队列的形式，直至 exec 命令出现，才会一次性发送队列里的命令去执行，而在执行这些命令的时候其他客户端就不能插入任何命令，这就是 redis 的事务执行机制</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>127.0.0.1:6379&gt; multi</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>127.0.0.1:6379&gt; set name zouzhu</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span>127.0.0.1:6379&gt; get name</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span>127.0.0.1:6379&gt; exec</span></span>
<span class="line"><span>1) OK</span></span>
<span class="line"><span>2) &quot;zouzhu&quot;</span></span></code></pre></div><p>从上面代码可以看到，先使用 multi 启动了 redis 的事务，因此进入了 set 和 get 命令，我们可以发现它并未马上执行，而是返回一个 “QUEUED” 的结果。这说明 redis 将其放入队列中，并不会马上执行，当命令执行到 exec 的时候它就会把队列中的命令发送给 redis 服务器，这样存储在队列中的命令就会被执行了，所以才会有 ok 和 value 的输出返回 。</p><h3 id="discard-取消事务" tabindex="-1">discard 取消事务 <a class="header-anchor" href="#discard-取消事务" aria-label="Permalink to &quot;discard 取消事务&quot;">​</a></h3><p>discard 命令后，在使用 exec 命令就会报错，因为 discard 命令已经取消了事务中的命令，而到了 exec 命令时，队列里面已经没有命令可以执行了，所以就出现了报错的情况 。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>127.0.0.1:6379&gt; multi</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>127.0.0.1:6379&gt; set email 2118224692@qq.com</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span>127.0.0.1:6379&gt; get email</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span>127.0.0.1:6379&gt; discard</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>127.0.0.1:6379&gt; exec</span></span>
<span class="line"><span>(error) ERR EXEC without MULTI</span></span></code></pre></div><h3 id="事务回滚" tabindex="-1">事务回滚 <a class="header-anchor" href="#事务回滚" aria-label="Permalink to &quot;事务回滚&quot;">​</a></h3><p>在我们将一系列事务命令放入队列中，在执行 exec() 命令后，队列里的命令将依次执行，当遇到命令的数据格式错误，但前面的写入操作操作已经执行，那我们怎么保证数据的正确性呢 ？redis 服务器帮我们给出了解决方案，那就是事务回滚，当队列的命令错误时，之前所有的写入操作命令将回滚，redis将返回错误信息 ：error : ......</p><h3 id="watch-命令监控事务" tabindex="-1">watch 命令监控事务 <a class="header-anchor" href="#watch-命令监控事务" aria-label="Permalink to &quot;watch 命令监控事务&quot;">​</a></h3><p>watch 监控 key ，监控 key 是否发生变化，在事务中会以 CAS 的方式判断 key 是否发生变化，如果发生变化，会导致事务中的所有命令执行失败，但不会报错 ，watch 相当于给字段新建了一个副本，然后进行对比 unwatch 提交事务，取消所有 key 的监控 ，事务提交失败的情况如下:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>127.0.0.1:6379&gt; set name zouzhu</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>127.0.0.1:6379&gt; watch name</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>127.0.0.1:6379&gt; multi</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>127.0.0.1:6379&gt; set name zouzhu@xiugai</span></span>
<span class="line"><span>QUEUED</span></span>
<span class="line"><span>127.0.0.1:6379&gt; exec</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span>127.0.0.1:6379&gt; get name</span></span>
<span class="line"><span>&quot;zouzhu@client&quot;</span></span></code></pre></div><p>我在终端 redis 服务器上，新建了一个 name ：zouzhu ，然后使用 watch name 命令对 name 进行监控，当我们从 redsi 客户端，对 name 字段进行更改后，终端的事务执行失败 。 这告诉我们在监控的前提下我们开启事务，只要还未 exec 提交事务，中途有别的客户端修改监控的字段，都会导致事务执行失败 。事务时间外修改字段不会影响到事务 。</p><h3 id="流水线" tabindex="-1">流水线 <a class="header-anchor" href="#流水线" aria-label="Permalink to &quot;流水线&quot;">​</a></h3><p>问题：</p><p>一般情况下，用户每次执行一个 redis 命令，客户端与服务器都需要进行一次通信，客户端将命令发送给服务器，而服务器则会将执行命令所得的结果返回给客户端 。 当程序执行一些复杂的操作时，客户端可能需要执行多个命令，并与服务器进行多次通信 。 在多数情况下，客户端在执行 redis 命令时，大部分等待时间都耗费在了发送命令请求和接收命令回复上面 。 解决方案 ： redis 流水线功能允许客户端一次将多个命令请求发送给服务器，并将被执行的多个命令请求的结果在一个命令回复中全部返回给客户端，使用这个功能可以有效的减少客户端在执行多个命令时需要与服务器进行通信的次数 。 spring 实现如下：</p><p>这里需要注意的是以下两点 ： 从实验可以看出，使用redis 流水线插入可以大幅度提高性能，它十分适合大数量的执行 。在运行如此多的命令时，需要考虑的另外一个问题是内存空间的消耗，因为对于程序而言，它最终会返回一个List 对象，如果过多的命令执行返回的结果都保存到这个 List 中，显然会造成内存消耗过大，尤其在那些高并发的网站中就很容易造成 JVM 内存溢出的异常， 这个时候应该考虑使用迭代的方法执行 Redis 命令 。与事务一样，使用流水线的过程中， 所有的命令也只是进入队列而没有执行，所以执行的命令返回值也为空，这也是需要注意的地方 。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RunWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SpringRunner.class)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SpringBootTest</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SpringBootRedisApplicationTests</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    StringRedisTemplate stringRedisTemplate;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Test</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contextLoads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Long start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        List list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stringRedisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">executePipelined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedisCallback&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Long </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">doInRedis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RedisConnection </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">connection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DataAccessException {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    connection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打开流水线</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000001</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1500000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        String key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;pipeline_&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i ;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        String value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;value_&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        connection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Long end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;RedisCallback return list : &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Pipeline 流水线插入 1000000 条记录耗时 : &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;毫秒 。&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Pipeline 流水线插入 1000000 条记录耗时 : 18554毫秒 。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2019-07-30 15:19:27.576  INFO 12512 --- [       Thread-1] o.s.s.concurrent.ThreadPoolTaskExecutor</span></span></code></pre></div><h3 id="发布订阅" tabindex="-1">发布订阅 <a class="header-anchor" href="#发布订阅" aria-label="Permalink to &quot;发布订阅&quot;">​</a></h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息 ，可以同时有几个订阅者，也可同时有几个发布者，现在我们演示怎么发布订阅 。 创建一个订阅对象，用于接收消息</p><p>创建一个发布对象，用于发布消息</p><p>发布订阅的相关命令</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psubscrice  pattern [pattern ...]               # 订阅一个或多个符合给定模式的频道 .</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pubsub subcommand [argument [argument ...]]     # 查看订阅与发布系统状态 .</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">publish channel message                         # 将信息发送到指定的频道 .</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">punsubscribe [pattern [pattern ...]]            # 退订所有给定模式的频道 .</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subscribe channel [channel ...]                 # 订阅给定的一个或多个频道的信息 .</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">unsubscribe [channel [channel ...]]             # 指退订给定的频道 .</span></span></code></pre></div><h2 id="redis-服务器操作" tabindex="-1">Redis 服务器操作 <a class="header-anchor" href="#redis-服务器操作" aria-label="Permalink to &quot;Redis 服务器操作&quot;">​</a></h2><h3 id="服务器管理" tabindex="-1">服务器管理 <a class="header-anchor" href="#服务器管理" aria-label="Permalink to &quot;服务器管理&quot;">​</a></h3><p>Redis 服务器命令主要是用于管理 redis 服务。以下实例演示了如何获取 redis 服务器的统计信息：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis 127.0.0.1:6379&gt; INFO</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 输出日志</span></span>
<span class="line"><span># Server</span></span>
<span class="line"><span>redis_version:2.8.13</span></span>
<span class="line"><span>redis_git_sha1:00000000</span></span>
<span class="line"><span>redis_git_dirty:0</span></span>
<span class="line"><span>redis_build_id:c2238b38b1edb0e2</span></span>
<span class="line"><span>redis_mode:standalone</span></span>
<span class="line"><span>os:Linux 3.5.0-48-generic x86_64</span></span>
<span class="line"><span>arch_bits:64</span></span>
<span class="line"><span>multiplexing_api:epoll</span></span>
<span class="line"><span>gcc_version:4.7.2</span></span>
<span class="line"><span>process_id:3856</span></span>
<span class="line"><span>run_id:0e61abd297771de3fe812a3c21027732ac9f41fe</span></span>
<span class="line"><span>tcp_port:6379</span></span>
<span class="line"><span>uptime_in_seconds:11554</span></span>
<span class="line"><span>uptime_in_days:0</span></span>
<span class="line"><span>hz:10</span></span>
<span class="line"><span>lru_clock:16651447</span></span>
<span class="line"><span>config_file:</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Clients</span></span>
<span class="line"><span>connected_clients:1</span></span>
<span class="line"><span>client-longest_output_list:0</span></span>
<span class="line"><span>client-biggest_input_buf:0</span></span>
<span class="line"><span>blocked_clients:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Memory</span></span>
<span class="line"><span>used_memory:589016</span></span>
<span class="line"><span>used_memory_human:575.21K</span></span>
<span class="line"><span>used_memory_rss:2461696</span></span>
<span class="line"><span>used_memory_peak:667312</span></span>
<span class="line"><span>used_memory_peak_human:651.67K</span></span>
<span class="line"><span>used_memory_lua:33792</span></span>
<span class="line"><span>mem_fragmentation_ratio:4.18</span></span>
<span class="line"><span>mem_allocator:jemalloc-3.6.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Persistence</span></span>
<span class="line"><span>loading:0</span></span>
<span class="line"><span>rdb_changes_since_last_save:3</span></span>
<span class="line"><span>rdb_bgsave_in_progress:0</span></span>
<span class="line"><span>rdb_last_save_time:1409158561</span></span>
<span class="line"><span>rdb_last_bgsave_status:ok</span></span>
<span class="line"><span>rdb_last_bgsave_time_sec:0</span></span>
<span class="line"><span>rdb_current_bgsave_time_sec:-1</span></span>
<span class="line"><span>aof_enabled:0</span></span>
<span class="line"><span>aof_rewrite_in_progress:0</span></span>
<span class="line"><span>aof_rewrite_scheduled:0</span></span>
<span class="line"><span>aof_last_rewrite_time_sec:-1</span></span>
<span class="line"><span>aof_current_rewrite_time_sec:-1</span></span>
<span class="line"><span>aof_last_bgrewrite_status:ok</span></span>
<span class="line"><span>aof_last_write_status:ok</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Stats</span></span>
<span class="line"><span>total_connections_received:24</span></span>
<span class="line"><span>total_commands_processed:294</span></span>
<span class="line"><span>instantaneous_ops_per_sec:0</span></span>
<span class="line"><span>rejected_connections:0</span></span>
<span class="line"><span>sync_full:0</span></span>
<span class="line"><span>sync_partial_ok:0</span></span>
<span class="line"><span>sync_partial_err:0</span></span>
<span class="line"><span>expired_keys:0</span></span>
<span class="line"><span>evicted_keys:0</span></span>
<span class="line"><span>keyspace_hits:41</span></span>
<span class="line"><span>keyspace_misses:82</span></span>
<span class="line"><span>pubsub_channels:0</span></span>
<span class="line"><span>pubsub_patterns:0</span></span>
<span class="line"><span>latest_fork_usec:264</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Replication</span></span>
<span class="line"><span>role:master</span></span>
<span class="line"><span>connected_slaves:0</span></span>
<span class="line"><span>master_repl_offset:0</span></span>
<span class="line"><span>repl_backlog_active:0</span></span>
<span class="line"><span>repl_backlog_size:1048576</span></span>
<span class="line"><span>repl_backlog_first_byte_offset:0</span></span>
<span class="line"><span>repl_backlog_histlen:0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># CPU</span></span>
<span class="line"><span>used_cpu_sys:10.49</span></span>
<span class="line"><span>used_cpu_user:4.96</span></span>
<span class="line"><span>used_cpu_sys_children:0.00</span></span>
<span class="line"><span>used_cpu_user_children:0.01</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Keyspace</span></span>
<span class="line"><span>db0:keys=94,expires=1,avg_ttl=41638810</span></span>
<span class="line"><span>db1:keys=1,expires=0,avg_ttl=0</span></span>
<span class="line"><span>db3:keys=1,expires=0,avg_ttl=0</span></span></code></pre></div><h3 id="redis-服务器的相关命令" tabindex="-1">Redis 服务器的相关命令 <a class="header-anchor" href="#redis-服务器的相关命令" aria-label="Permalink to &quot;Redis 服务器的相关命令&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>异步执行一个 AOF（AppendOnly File） 文件重写操作</span></span>
<span class="line"><span>BGREWRITEAOF</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在后台异步保存当前数据库的数据到磁盘</span></span>
<span class="line"><span>BGSAVE</span></span>
<span class="line"><span></span></span>
<span class="line"><span>关闭客户端连接</span></span>
<span class="line"><span>CLIENT KILL [ip:port] [ID client-id]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>获取连接到服务器的客户端连接列表</span></span>
<span class="line"><span>CLIENT LIST</span></span>
<span class="line"><span></span></span>
<span class="line"><span>获取连接的名称</span></span>
<span class="line"><span>CLIENT GETNAME</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在指定时间内终止运行来自客户端的命令</span></span>
<span class="line"><span>CLIENT PAUSE timeout</span></span>
<span class="line"><span></span></span>
<span class="line"><span>7   CLIENT SETNAME connection-name</span></span>
<span class="line"><span>设置当前连接的名称</span></span>
<span class="line"><span></span></span>
<span class="line"><span>8   CLUSTER SLOTS</span></span>
<span class="line"><span>获取集群节点的映射数组</span></span>
<span class="line"><span></span></span>
<span class="line"><span>9   COMMAND</span></span>
<span class="line"><span>获取 Redis 命令详情数组</span></span>
<span class="line"><span></span></span>
<span class="line"><span>10  COMMAND COUNT</span></span>
<span class="line"><span>获取 Redis 命令总数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>11  COMMAND GETKEYS</span></span>
<span class="line"><span>获取给定命令的所有键</span></span>
<span class="line"><span></span></span>
<span class="line"><span>12  TIME</span></span>
<span class="line"><span>返回当前服务器时间</span></span>
<span class="line"><span></span></span>
<span class="line"><span>13  COMMAND INFO command-name [command-name ...]</span></span>
<span class="line"><span>获取指定 Redis 命令描述的数组</span></span>
<span class="line"><span></span></span>
<span class="line"><span>14  CONFIG GET parameter</span></span>
<span class="line"><span>获取指定配置参数的值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>15  CONFIG REWRITE</span></span>
<span class="line"><span>对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写</span></span>
<span class="line"><span></span></span>
<span class="line"><span>16  CONFIG SET parameter value</span></span>
<span class="line"><span>修改 redis 配置参数，无需重启</span></span>
<span class="line"><span></span></span>
<span class="line"><span>17  CONFIG RESETSTAT</span></span>
<span class="line"><span>重置 INFO 命令中的某些统计数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>18  DBSIZE</span></span>
<span class="line"><span>返回当前数据库的 key 的数量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>19  DEBUG OBJECT key</span></span>
<span class="line"><span>获取 key 的调试信息</span></span>
<span class="line"><span></span></span>
<span class="line"><span>20  DEBUG SEGFAULT</span></span>
<span class="line"><span>让 Redis 服务崩溃</span></span>
<span class="line"><span></span></span>
<span class="line"><span>21  FLUSHALL</span></span>
<span class="line"><span>删除所有数据库的所有key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>22  FLUSHDB</span></span>
<span class="line"><span>删除当前数据库的所有key</span></span>
<span class="line"><span></span></span>
<span class="line"><span>23  INFO [section]</span></span>
<span class="line"><span>获取 Redis 服务器的各种信息和统计数值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>24  LASTSAVE</span></span>
<span class="line"><span>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</span></span>
<span class="line"><span></span></span>
<span class="line"><span>25  MONITOR</span></span>
<span class="line"><span>实时打印出 Redis 服务器接收到的命令，调试用</span></span>
<span class="line"><span></span></span>
<span class="line"><span>26  ROLE</span></span>
<span class="line"><span>返回主从实例所属的角色</span></span>
<span class="line"><span></span></span>
<span class="line"><span>27  SAVE</span></span>
<span class="line"><span>同步保存数据到硬盘</span></span>
<span class="line"><span></span></span>
<span class="line"><span>28  SHUTDOWN [NOSAVE] [SAVE]</span></span>
<span class="line"><span>异步保存数据到硬盘，并关闭服务器</span></span>
<span class="line"><span></span></span>
<span class="line"><span>29  SLAVEOF host port</span></span>
<span class="line"><span>将当前服务器转变为指定服务器的从属服务器(slave server)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>30  SLOWLOG subcommand [argument]</span></span>
<span class="line"><span>管理 redis 的慢日志</span></span>
<span class="line"><span></span></span>
<span class="line"><span>31  SYNC</span></span>
<span class="line"><span>用于复制功能(replication)的内部命令</span></span></code></pre></div><h3 id="redis-连接" tabindex="-1">Redis 连接 <a class="header-anchor" href="#redis-连接" aria-label="Permalink to &quot;Redis 连接&quot;">​</a></h3><p>Redis 连接命令主要是用于连接 redis 服务，以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis 127.0.0.1:6379&gt; AUTH &quot;password&quot;</span></span>
<span class="line"><span>OK</span></span>
<span class="line"><span>redis 127.0.0.1:6379&gt; PING</span></span>
<span class="line"><span>PONG</span></span></code></pre></div><p>Redis 连接命令，下表列出了 redis 连接的基本命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>序号  命令及描述</span></span>
<span class="line"><span>1 AUTH password</span></span>
<span class="line"><span>验证密码是否正确</span></span>
<span class="line"><span>2 ECHO message</span></span>
<span class="line"><span>打印字符串</span></span>
<span class="line"><span>3 PING</span></span>
<span class="line"><span>查看服务是否运行</span></span>
<span class="line"><span>4 QUIT</span></span>
<span class="line"><span>关闭当前连接</span></span>
<span class="line"><span>5 SELECT index</span></span>
<span class="line"><span>切换到指定的数据库</span></span></code></pre></div><h3 id="redis-脚本" tabindex="-1">Redis 脚本 <a class="header-anchor" href="#redis-脚本" aria-label="Permalink to &quot;Redis 脚本&quot;">​</a></h3><p>Redis 脚本使用 lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 eval 语法，eval 命令的基本语法如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis 127.0.0.1:6379&gt; eval lua-script key-number [key1 key2 key3 ...] [value1 value2 value3 ...]</span></span></code></pre></div><p>eval 代表执行 Lua 语言的命令，Lua-script 代表 Lua 语言脚本，key-num 整数代表参数中有多少个key，需要注意的是redis中key是从1开始的，如果没有key的参数，那么写 0，演示常用的写法 这个脚本只是返回一个字符串，并不需要任何参数，所以 key-num 填写了 0，代表着没有任何 key 参数 。按照脚本的结果就是返回 hello word</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>127.0.0.1:6379&gt; eval &quot;return &#39;hello redis lua ! &#39;&quot;  0</span></span>
<span class="line"><span>&quot;hello redis lua ! &quot;</span></span></code></pre></div><p>设置一个键值对，可以在 Lua 语言中采用 redis.call(command，key[param1] ，key[param2 .. ]) ，其中 command 是命令，包括 set，get，del 。Key 是被操作的键值对 。param1，param2 ...代表给 key 的参数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>127.0.0.1:6379&gt; eval &quot;redis.call(&#39;set&#39;, KEYS[1], ARGV[1])&quot; 1 Email [zouzhu@net.cn.com](mailto:zouzhu@net.cn.com)</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>127.0.0.1:6379&gt; get Emial</span></span>
<span class="line"><span>(nil)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>127.0.0.1:6379&gt; get Email</span></span>
<span class="line"><span>&quot;[zouzhu@net.cn.com](mailto:zouzhu@net.cn.com)&quot;</span></span>
<span class="line"><span>get</span></span>
<span class="line"><span></span></span>
<span class="line"><span>127.0.0.1:6379&gt; eval &quot;return redis.call(&#39;get&#39;, KEYS[1])&quot; 1 Email</span></span>
<span class="line"><span>&quot;[zouzhu@net.cn.com](mailto:zouzhu@net.cn.com)&quot;</span></span></code></pre></div><p>加密脚本，有时可能需要多次执行同样一段脚本，这个时候可以使用Redis缓存脚本的功能，在redis中脚本会通过 sha-1 签名算法加密脚本，可以通过这个脚本执行 Lua，$ script load</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>127.0.0.1:6379&gt; script load &quot;return redis.call(&#39;get&#39;, KEYS[1])&quot;</span></span>
<span class="line"><span>&quot;4e6d8fc8bb01276962cce5371fa795a7763657ae&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>127.0.0.1:6379&gt; evalsha 4e6d8fc8bb01276962cce5371fa795a7763657ae 1 Email</span></span>
<span class="line"><span>&quot;[zouzhu@net.cn.com](mailto:zouzhu@net.cn.com)&quot;</span></span></code></pre></div><p>以下实例演示了 redis 脚本工作过程：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>redis 127.0.0.1:6379&gt; eval &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1) &quot;key1&quot;</span></span>
<span class="line"><span>2) &quot;key2&quot;</span></span>
<span class="line"><span>3) &quot;first&quot;</span></span>
<span class="line"><span>4) &quot;second&quot;</span></span>
<span class="line"><span>Redis 脚本命令，下表列出了 redis 脚本常用命令：</span></span>
<span class="line"><span>执行 Lua 脚本</span></span>
<span class="line"><span>EVAL script numkeys key [key ...] arg [arg ...]</span></span>
<span class="line"><span>执行 Lua 脚本</span></span>
<span class="line"><span>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</span></span>
<span class="line"><span>查看指定的脚本是否已经被保存在缓存当中</span></span>
<span class="line"><span>SCRIPT EXISTS script [script ...]</span></span>
<span class="line"><span>从脚本缓存中移除所有脚本</span></span>
<span class="line"><span>SCRIPT FLUSH</span></span>
<span class="line"><span>杀死当前正在运行的 Lua 脚本。</span></span>
<span class="line"><span>SCRIPT KILL</span></span>
<span class="line"><span>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本</span></span>
<span class="line"><span>SCRIPT LOAD script</span></span></code></pre></div><h3 id="redis-配置-备份-持久化-主从配置" tabindex="-1">Redis 配置(备份，持久化，主从配置) <a class="header-anchor" href="#redis-配置-备份-持久化-主从配置" aria-label="Permalink to &quot;Redis 配置(备份，持久化，主从配置)&quot;">​</a></h3><p>Redis 备份( 持久化 ) redis 中存在两种方式的备份 一种是快照，它是备份当前瞬间 redis 在内存中的数据记录 ；对于快照备份而言，如果当前Redis的数据量大，备份可能导致 redis 卡顿，但是恢复重启要执行是比较快速的 ； 另一种是追加文件aof，其作用就是当 redis 执行写命令后，在一定的条件下将执行的写命令依次保存在 redis 的文件中，将来就可以依次执行那些保存的命令恢复 redis 的数据了 。对于aof 备份而言，它只是追加写入命令，所以备份一般不会造成 redis 卡顿，但是恢复重启要执行更多的命令，备份文件可能也很大 使用者使用的时候要注意，在redis 中允许使用其中的一种，同时使用两种，或两者都不用，所以具体使用何种方式进行备份和持久化是用户可以通过配置决定的</p><p>service-redis-config</p><p>当 900 秒执行 1 个写命令时 , 启动快照备份 ， 当 300 秒执行 10 个写命令时 , 启动快照备份</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>save 900 1</span></span>
<span class="line"><span>save 300 10</span></span>
<span class="line"><span>save 60 10000</span></span></code></pre></div><p>bgsave 它是一个异步保存命令，也就是系统将启动另外一条进程，对redis的数据保存到对应的数据文件中，它和 save命令最大的不同是它不会阻塞客户端的写入，也就是在执行bgsave的时候，允许客户端继续读/写 redis，在默认情况下，如果 redis执行bgsave失败后，redis 将停止接受写操作，这样是一种强硬的方式让用户知道数据不能正确的持久化到磁盘，否则就会没人注意到灾难的发生，如果后台保存进程重新启动工作了，redis 也将自动允许写操作，然而如果安装了靠谱的监控，可能不希望 redis 这样做，那么你可以将其改为 no</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>stop-writes-on-bgsave-error yes</span></span></code></pre></div><p>这个命令意思是否对 rbd 文件进行检验，如果是将 rbd 文件检验，从 dbfilename 的配置可以知道，rdb文件实际是 redis 持久化的数据文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>rdbchecksum yes</span></span></code></pre></div><p>它是数据文件，当采用快照模式备份(持久化)时，redis将使用它保存数据，将来可以使用它恢复数据</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>dbfilename dump.rdb</span></span></code></pre></div><p>如果 appendonly 配置为 no，则不启动 AOF 方式进行备份 ，如果 appendonly 配置为 yes，则以AOF 方式备份 redis 数据，那么此时 redis 会按照配置，在特定的时候执行追加命令，用以备份数据</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>appendonly  no</span></span></code></pre></div><p>这里定义追加的写入文件为 appendonly.aof，采用 aof 追加文件备份的时候命令都会写到这里</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>appendfilename &quot;appendonly.aof&quot;</span></span></code></pre></div><p>持久化文件在 redis 安装目录下，我们也可以更改其路径</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>dir ./</span></span></code></pre></div><p>aof 文件和Redis命令是同步频率的，假设配置为always,其含义为当Redis执行命令的时候，则同时同步到AOF文件，这样会使得Redis同步刷新AOF文件，造成缓慢。而采用evarysec则代表每秒同步一次命令到AOF文件。采用no的时候，则由客户端调用命令执行备份，Redis 本身不备份文件。对于采用always配置的时候，每次命令都会持久化，它的 好处在于安全，坏处在于每次都持久化性能较差。采用evarysec则每秒同步，安全性不如always,备份可能会丢失1秒以内的命令，但是隐患也不大，安全度尚可，性能可以得到保障。采用no,则性能有所保障，但是由于失去备份，所以安全性比较差。笔者建议采用默认配置everysee,这样在保证性能的同时，也在一定程度 上保证了安全性</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>appendfsync always</span></span>
<span class="line"><span></span></span>
<span class="line"><span>appendfsync everysec</span></span>
<span class="line"><span></span></span>
<span class="line"><span>appendfsync no</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-b77f9094><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"readme.md\":\"BW9-GITo\",\"api-examples.md\":\"D8o61NPh\",\"document_services_index.md\":\"D_V0san1\",\"document_services_rails_index.md\":\"nDD5s_p_\",\"document_services_rails_rails routing 路由器.md\":\"BwiM-NYJ\",\"document_services_redis.md\":\"C_q9rnPa\",\"document_services_rails_rails model 数据模型层.md\":\"Dzb0qoVN\",\"document_services_ruby_index.md\":\"CEPsRsiN\",\"document_views_code.md\":\"DsSf72O5\",\"document_services_shell.md\":\"C6x32ekZ\",\"document_views_index.md\":\"C9oWbb2A\",\"document_workers_index.md\":\"Chf-eEw8\",\"document_workers_money.md\":\"DeITRM9R\",\"document_workers_timehut_interface.md\":\"DTwLAad0\",\"document_workers_timehut_index.md\":\"lDZA-h0Q\",\"document_workers_timehut_database.md\":\"DRrtErU4\",\"index.md\":\"BCByAl7c\",\"document_workers_timehut_ubuntu.md\":\"DRYLpuD3\",\"markdown-examples.md\":\"DNsgJPQL\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"VitePress\",\"description\":\"bolg ...\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.png\",\"siteTitle\":false,\"search\":{\"provider\":\"local\"},\"outline\":{\"label\":\"目录大纲\",\"level\":[2,3]},\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"联系我\",\"link\":\"/\"}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/zouzhu-code-89\"},{\"icon\":\"twitter\",\"link\":\"...\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>